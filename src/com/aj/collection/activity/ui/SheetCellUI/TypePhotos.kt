package com.aj.collection

import android.Manifest
import android.app.Activity
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.content.pm.PackageManager
import android.graphics.Color
import android.graphics.drawable.ColorDrawable
import android.support.design.widget.TextInputEditText
import android.support.design.widget.TextInputLayout
import android.support.v4.app.ActivityCompat
import android.support.v4.content.ContextCompat
import android.support.v7.widget.AppCompatRadioButton
import android.support.v7.widget.LinearLayoutManager
import android.support.v7.widget.RecyclerView
import android.support.v7.widget.StaggeredGridLayoutManager
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.view.ViewTreeObserver
import android.widget.*
import at.markushi.ui.CircleButton
import com.aj.Constant
import com.aj.Constant.DEFAULT_IMAGE_HEIGHT_DP
import com.aj.collection.activity.CameraView
import com.aj.collection.activity.CollectionApplication
import com.aj.collection.activity.GatherActivity
import com.aj.collection.bean.SheetCell
import com.aj.collection.activity.tools.MediaManager
import com.aj.collection.activity.tools.ScreenUtil
import com.aj.collection.activity.tools.SheetProtocol
import com.aj.collection.activity.tools.Util
import com.aj.collection.activity.GalleryActivity
import com.baidu.location.BDLocation
import com.squareup.picasso.Picasso
import org.jetbrains.anko.onClick
import org.jetbrains.anko.toast
import org.json.JSONArray
import org.json.JSONObject
import java.io.File

/**
 * 拍照单元格(type_photos): 用于采集照片。单元格值、单元格是否可打印、单元格是否默认勾选打印属性对其无效
 * Created by kevin on 17-4-18.
 * Mail: chewenkaich@gmail.com
 */
class TypePhotos(var mContext: Context, var sheetCell: SheetCell, val autoGeneratedSheetID: String) : CellBaseAttributes() {

    /**
     * 获取打印的内容
     */
    override fun getPrintContent(): String {
        return ""
    }

    /**
     * 设置单元格为不可打印
     */
    override fun setCellNotPrint() {
        cell_printable?.isChecked = false
        cell_printable?.isClickable = false
    }

    /**
     * 将内容填到单元格
     */
    override fun setFilledContent(content: String) {
        val photoFiles = ArrayList<File>()
        val photosName = content.splitKeeping(",")
        for (photoName in photosName) {
            photoFiles.add(File(Util.getMediaFolder(mContext) + File.separator + autoGeneratedSheetID + File.separator +
                    cell_name!!.text.toString() + File.separator + photoName))
        }
        gallaryAdaper?.updateUI(photoFiles)
    }

    /**
     * 设置单元格为不可更改
     */
    override fun setCellDisable() {
        takePhotoButton?.visibility = View.GONE
    }

    /**
     *获取单元格名称(cell_name)
     */
    override fun get_cell_name(): String {
        return sheetCell.cell_name
    }

    /**
     * 获取单元格类型(cell_type)
     */
    override fun get_cell_type(): String {
        return sheetCell.cell_type
    }

    /**
     * 获取单元格值(cell_value)
     */
    override fun get_cell_value(): String {
        return MediaManager().getLatestCameraFiles(
                File(Util.getMediaFolder(mContext) + File.separator + autoGeneratedSheetID +
                        File.separator + cell_name!!.text)).toString()
    }

    /**
     * 获取单元格是否可编辑(cell_editable)
     */
    override fun get_cell_editable(): String {
        return if (sheetCell.cell_editable == SheetProtocol().True) SheetProtocol().True else SheetProtocol().False
    }

    /**
     * 获取单元格是否为必填(cell_fill_required)
     */
    override fun get_cell_fill_required(): String {
        return if (sheetCell.cell_fill_required == SheetProtocol().True) SheetProtocol().True else SheetProtocol().False
    }

    /**
     * 获取单元格是否可打印(cell_printable)
     */
    override fun get_cell_printable(): String {
        return if (sheetCell.cell_printable == SheetProtocol().True) SheetProtocol().True else SheetProtocol().False
    }

    /**
     * 获取单元格是否默认勾选打印(cell_default_print)
     */
    override fun get_cell_default_print(): String {
        return if (sheetCell.cell_default_print == SheetProtocol().True) SheetProtocol().True else SheetProtocol().False
    }

    /**
     * 获取单元格可否被加样(cell_copyable)
     */
    override fun get_cell_copyable(): String {
        return if (sheetCell.cell_copyable == SheetProtocol().True) SheetProtocol().True else SheetProtocol().False
    }

    /**
     * 根据单元格内容生成Json
     */
    override fun getJsonContent(): JSONObject {
        // 转换图片名字为Json
        val photoFiles = MediaManager().getLatestCameraFiles(
                File(Util.getMediaFolder(mContext) + File.separator + autoGeneratedSheetID +
                        File.separator + cell_name!!.text))
        var values = ""
        for (index in photoFiles.indices) {
            if (values.isEmpty())
                values = photoFiles[index].name
            else
                values = values + "," + photoFiles[index].name
        }

        // 将内容生成Json
        val json = JSONObject()
        json.put(SheetProtocol().CELL_NAME, get_cell_name())
        json.put(SheetProtocol().CELL_TYPE, get_cell_type())
        json.put(SheetProtocol().CELL_VALUE, values)
        json.put(SheetProtocol().CELL_EDITABLE, get_cell_editable())
        json.put(SheetProtocol().CELL_FILL_REQUIRED, get_cell_fill_required())
        json.put(SheetProtocol().CELL_PRINTABLE, get_cell_printable())
        json.put(SheetProtocol().CELL_DEFAULT_PRINT, get_cell_default_print())
        json.put(SheetProtocol().CELL_COPYABLE, get_cell_copyable())
        return json
    }

    /**
     * 必填的内容是否已经填写
     */
    override fun isFilled(): Boolean {
        if (sheetCell.cell_fill_required == (SheetProtocol().False))
            return true
        else {
            val photosNumber = MediaManager().getLatestCameraFiles(
                    File(Util.getMediaFolder(mContext) + File.separator + autoGeneratedSheetID +
                            File.separator + cell_name!!.text)).size
            return photosNumber != 0
        }

    }

    /**
     * 获取LinearLayout的界面
     */
    override fun getView(): LinearLayout {
        return linearLayout!!
    }

    /**
     * 注册位置信息广播接收器
     */
    fun registerLocationBroadcast() {
        val filter = IntentFilter(Constant.LOCATION_BROADCAST_ACT)
        mContext.registerReceiver(locationReceiver, filter)
    }

    /**
     * 取消注册位置信息广播接收器
     */
    fun unregisterLocationBroadcast() {
        mContext.unregisterReceiver(locationReceiver)
    }

    /**
     * 注册新照片广播接收器
     */
    fun registerNewPhotoBroadcast() {
        val filter = IntentFilter(Constant.NEW_PHOTO_BROADCAST_ACT)
        mContext.registerReceiver(newPhotoReceive, filter)
    }

    /**
     * 取消注册新照片广播接收器
     */
    fun unregisterNewPhotoBroadcast() {
        mContext.unregisterReceiver(newPhotoReceive)
    }

    var contentView: View? = null  // 设计的界面
    var linearLayout: LinearLayout? = null
    var cell_name: TextView? = null
    var cell_value: RecyclerView? = null  // 盛放照片
    var gallaryAdaper: GallaryAdaper? = null // 照片适配器
    var numberIndicator: TextView? = null  // 数量指示器
    var takePhotoButton: Button? = null // 拍照按钮
    var cellIdentity = 0  // 拍照单元格的身份ID
    var cell_fill_required: TextView? = null
    var cell_printable: CheckBox? = null
    // Location Info
    var locationPause = false  // 是否暂停定位
    var country = ""  // 国家
    var province = ""  // 省
    var city = ""  // 市
    var district = ""  // 区域
    var street = ""  // 街道
    var longitude = ""  // 经度信息
    var latitude = ""  // 纬度信息
    var location_info_type = BDLocation.TypeOffLineLocation  // 定位类型
    var locationString = ""  // 全面的位置信息

    /**
     * 接受位置信息
     */
    private val locationReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context, intent: Intent) {
            val action = intent.action
            if (Constant.LOCATION_BROADCAST_ACT == action) {
                if (locationPause)
                    return
                val location = intent.getParcelableExtra<BDLocation>(Constant.LOCATION_BROADCAST_VALUE)
                country = location.country
                province = location.province
                city = location.city
                district = location.district
                street = location.street

                longitude = location.longitude.toString()  // 经度信息
                latitude = location.latitude.toString()  // 纬度信息
                location_info_type = location.locType  // 定位类型
                var location_type_str = ""  // 定位类型字符
                when (location_info_type) {
                    BDLocation.TypeGpsLocation -> location_type_str = "GPS定位"
                    BDLocation.TypeCacheLocation -> location_type_str = "缓存的位置(此状态无法保存)"
                    BDLocation.TypeNetWorkLocation -> location_type_str = "网络定位"
                    BDLocation.TypeNone -> location_type_str = "无(此状态无法保存)"
                    BDLocation.TypeOffLineLocation -> location_type_str = "离线定位(此状态无法保存)"
                }

                locationString = "定位地址：$province$city$district$street\n经度:$longitude\n纬度:$latitude\n定位类型:$location_type_str"
            }
        }
    }

    /**
     * 接受新照片广播
     */
    private val newPhotoReceive = object : BroadcastReceiver() {
        override fun onReceive(context: Context, intent: Intent) {
            val action = intent.action
            if (Constant.NEW_PHOTO_BROADCAST_ACT == action) {
                val cellIdentity = intent.getIntExtra(Constant.CELL_ID_EXTRA_KEY, 0)
                if (cellIdentity == this@TypePhotos.cellIdentity)
                    gallaryAdaper!!.updateUI()
            }
        }
    }

    init {
        // 导入界面
        val mInflater: LayoutInflater = LayoutInflater.from(mContext)
        contentView = mInflater.inflate(R.layout.sheet_cell_photos, null)
        // LinearLayout
        linearLayout = contentView!!.findViewById(R.id.cell_edit_text_linear_layout) as LinearLayout
        // 填写单元格的名字
        cell_name = contentView!!.findViewById(R.id.cell_name) as TextView
        cell_name!!.text = sheetCell.cell_name
        // 填写单元格的内容
        cell_value = contentView!!.findViewById(R.id.cell_value) as RecyclerView
        numberIndicator = contentView!!.findViewById(R.id.number_indicator) as TextView
        numberIndicator?.text = ""
        numberIndicator?.visibility = View.GONE
        gallaryAdaper = GallaryAdaper(mContext, MediaManager().getLatestCameraFiles(
                File(Util.getMediaFolder(mContext) + File.separator + autoGeneratedSheetID +
                        File.separator + cell_name!!.text)), autoGeneratedSheetID, cell_name!!.text.toString(), numberIndicator!!)
        cell_value!!.adapter = gallaryAdaper
        val layoutManager = LinearLayoutManager(mContext, LinearLayoutManager.HORIZONTAL, false)
        layoutManager.scrollToPosition(0)// Optionally customize the position you want to default scroll to
        cell_value!!.layoutManager = layoutManager// Attach layout manager to the RecyclerView
        val gridLayoutManager = StaggeredGridLayoutManager(1, StaggeredGridLayoutManager.HORIZONTAL)// First param is number of columns and second param is orientation i.e Vertical or Horizontal
        cell_value!!.layoutManager = gridLayoutManager// Attach the layout manager to the recycler view
        cell_value!!.setHasFixedSize(true)
        // 定义拍照按钮功能
        takePhotoButton = contentView!!.findViewById(R.id.takeAPhoto) as Button
        takePhotoButton!!.onClick {
            // 定位信息准确时才可以拍照
            if (location_info_type == BDLocation.TypeGpsLocation ||
                    location_info_type == BDLocation.TypeNetWorkLocation) {
                val intent = Intent(mContext, CameraView::class.java)
                intent.putExtra("mediaRootPath", Util.getMediaFolder(mContext) + File.separator + autoGeneratedSheetID +
                        File.separator + cell_name!!.text.toString())    //将存储图片根目录传递过去,放在以【抽样的编号】+【单元格名字】的文件夹中
                intent.putExtra("view_id", cellIdentity)        //控件ID
                intent.putExtra("location", locationString)
                intent.putExtra("number", autoGeneratedSheetID)
                (mContext as GatherActivity).startActivityForResult(intent, GatherActivity.REQUESTCODEFORPICTURE)
            } else
                mContext.toast("正在定位,请稍后...")

        }
        // 生成照相单元格ID
        cellIdentity = ++((mContext as GatherActivity).application as CollectionApplication).cellIdentity
        // 设置单元格可编辑状态(不受该属性影响)
        // ？@##￥￥%%%@#￥！
        // 设置单元格必填状态
        cell_fill_required = contentView!!.findViewById(R.id.cell_fill_required) as TextView
        if (sheetCell.cell_fill_required == (SheetProtocol().False))
            cell_fill_required!!.visibility = View.INVISIBLE
        // 设置单元格默认打印状态
        cell_printable = contentView!!.findViewById(R.id.cell_printable) as CheckBox
        cell_printable!!.setBackgroundResource(R.drawable.selector_checkbox_print)
        cell_printable!!.setButtonDrawable(ColorDrawable(Color.TRANSPARENT))
        cell_printable!!.visibility = View.INVISIBLE
        cell_printable!!.isChecked = sheetCell.cell_default_print == (SheetProtocol().True)
        // 注册新照片拍摄完成和位置信息的监听
        registerLocationBroadcast()
        registerNewPhotoBroadcast()
    }

    /**
     * 分割字符串
     */
    fun String.splitKeeping(str: String): List<String> {
        return this.split(str).flatMap { listOf(it) }.dropLast(0).filterNot { it.isEmpty() }
    }

    /**
     * RecycleView 的 adapter
     */
    class GallaryAdaper(var mContext: Context, private val photoFiles: ArrayList<File>,
                        val autoGeneratedSheetID: String, val cell_name: String, val photoNumberIndicator: TextView?) : RecyclerView.Adapter<GallaryAdaper.ViewHolder>() {

        val context: Context
            get() = mContext.applicationContext

        override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
            val context = parent.context
            val inflater = LayoutInflater.from(context)

            // Inflate the custom layout
            val contactView = inflater.inflate(R.layout.type_photos_adapter_layout, parent, false)

            // Return a new holder instance
            return ViewHolder(contactView)
        }

        override fun onBindViewHolder(holder: ViewHolder, position: Int) {
            // Get the data model based on position
            val photoFile = photoFiles[position]

            // Set item views based on your views and data model
            val image = holder.image
            image.viewTreeObserver
                    .addOnGlobalLayoutListener(object : ViewTreeObserver.OnGlobalLayoutListener {
                        // Wait until layout to call Picasso
                        override fun onGlobalLayout() {
                            // Ensure we call this only once
                            image.viewTreeObserver
                                    .removeOnGlobalLayoutListener(this)
                        }
                    })
            if (ContextCompat.checkSelfPermission(mContext, Manifest.permission.READ_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED) {
                Picasso.with(mContext).load(photoFile).resize(0,
                        ScreenUtil.dpToPx(mContext, DEFAULT_IMAGE_HEIGHT_DP)).into(image)
            } else {
                Picasso.with(mContext).load(R.drawable.image_read_fail).resizeDimen(0,
                        ScreenUtil.dpToPx(mContext, DEFAULT_IMAGE_HEIGHT_DP)).into(image)
            }
            image.setOnClickListener {
                val intent = Intent()
                intent.putExtra(Constant.GALLERY_CLICK_POSITION, holder.adapterPosition)
                intent.putExtra(Constant.PHOTO_MEDIA_FOLDER, Util.getMediaFolder(mContext) + File.separator + autoGeneratedSheetID + File.separator + cell_name)
                intent.setClass(mContext, GalleryActivity::class.java)
                mContext.startActivity(intent)
            }
            val button = holder.removeButton

            button.setOnClickListener {
                photoFile.delete()
                updateUI()
            }
        }

        override fun getItemCount(): Int {
            return photoFiles.size
        }

        fun updateUI() {
            this.photoFiles.clear()
            this.photoFiles.addAll(MediaManager().getLatestCameraFiles(
                    File(Util.getMediaFolder(mContext) + File.separator + autoGeneratedSheetID + File.separator + cell_name)))
            this.notifyDataSetChanged()
            // 更新指示器
            if (this.photoFiles.isEmpty()) {
                photoNumberIndicator?.text = ""
                photoNumberIndicator?.visibility = View.GONE
            }else{
                photoNumberIndicator?.visibility = View.VISIBLE
                photoNumberIndicator?.text = "已拍"+this.photoFiles.size.toString()+"张，左右滑动浏览，点击查看大图"
            }
        }

        fun updateUI(photoFiles: ArrayList<File>) {
            this.photoFiles.clear()
            this.photoFiles.addAll(photoFiles)
            this.notifyDataSetChanged()
            // 更新指示器
            if (this.photoFiles.isEmpty()) {
                photoNumberIndicator?.text = ""
                photoNumberIndicator?.visibility = View.GONE
            }else{
                photoNumberIndicator?.visibility = View.VISIBLE
                photoNumberIndicator?.text = "已拍"+this.photoFiles.size.toString()+"张，左右滑动浏览，点击查看大图"
            }
        }

        // Provide a direct reference to each of the views within a data item
        // Used to cache the views within the item layout for fast access
        class ViewHolder// We also create a constructor that accepts the entire item row
        // and does the view lookups to find each subview
        (itemView: View) : RecyclerView.ViewHolder(itemView) {
            // Your holder should contain a member variable
            // for any view that will be set as you render a row
            var image: ImageView
            var removeButton: CircleButton

            init {

                image = itemView.findViewById(R.id.gallary_image) as ImageView
                removeButton = itemView.findViewById(R.id.remove_gallary_button) as CircleButton
            }// Stores the itemView in a public final member variable that can be used
            // to access the context from any ViewHolder instance.
        }
    }
}