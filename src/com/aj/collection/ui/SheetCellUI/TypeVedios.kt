package com.aj.collection

import android.Manifest
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.content.pm.PackageManager
import android.graphics.Color
import android.graphics.drawable.ColorDrawable
import android.media.ThumbnailUtils.createVideoThumbnail
import android.net.Uri
import android.os.AsyncTask
import android.os.Build
import android.os.Environment
import android.provider.MediaStore
import android.support.v4.content.ContextCompat
import android.support.v4.content.FileProvider
import android.support.v7.widget.LinearLayoutManager
import android.support.v7.widget.RecyclerView
import android.support.v7.widget.StaggeredGridLayoutManager
import android.telephony.TelephonyManager
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.view.ViewTreeObserver
import android.widget.*
import at.markushi.ui.CircleButton
import com.aj.Constant
import com.aj.Constant.DEFAULT_IMAGE_HEIGHT_DP
import com.aj.collection.activity.CollectionApplication
import com.aj.collection.activity.SheetActivity
import com.aj.collection.bean.SheetCell
import com.aj.collection.http.URLs
import com.aj.collection.tools.MediaManager
import com.aj.collection.tools.ScreenUtil
import com.aj.collection.tools.SheetProtocol
import com.aj.collection.tools.Util
import com.aj.collection.tools.Util.getBitmapUri
import com.baidu.location.BDLocation
import com.squareup.picasso.Picasso
import org.jetbrains.anko.doAsync
import org.jetbrains.anko.onClick
import org.jetbrains.anko.toast
import org.jetbrains.anko.uiThread
import org.json.JSONObject
import vi.com.gdi.bgl.android.java.EnvDrawText.buffer
import java.io.File
import java.io.FileOutputStream
import java.io.IOException
import java.net.HttpURLConnection
import java.net.URL

/**
 * 录像单元格(type_vedios): 用于拍摄视频。单元格值、单元格是否可打印、单元格是否默认勾选打印属性对其无效
 * Created by kevin on 17-4-18.
 * Mail: chewenkaich@gmail.com
 */
class TypeVedios(var mContext: Context, var sheetCell: SheetCell, val autoGeneratedSheetID: String) : CellBaseAttributes() {

    /**
     * 获取打印的内容
     */
    override fun getPrintContent(): String {
        return ""
    }

    /**
     * 设置单元格为不可打印
     */
    override fun setCellNotPrint() {
        cell_printable?.isChecked = false
        cell_printable?.isClickable = false
    }

    /**
     * 将内容填到单元格
     */
    override fun setFilledContent(content: String) {
        val veidoFiles = ArrayList<File>()
        val vediosName = content.splitKeeping(",")
        for (vedioName in vediosName) {
            veidoFiles.add(File(Util.getMediaFolder(mContext) + File.separator + autoGeneratedSheetID + File.separator +
                    cell_name!!.text.toString() + File.separator + vedioName))
        }
        gallaryAdaper?.updateUI(veidoFiles)
    }

    /**
     * 设置单元格为不可更改
     */
    override fun setCellDisable() {
        takeVedioButton?.visibility = View.GONE
    }

    /**
     *获取单元格名称(cell_name)
     */
    override fun get_cell_name(): String {
        return sheetCell.cell_name
    }

    /**
     * 获取单元格类型(cell_type)
     */
    override fun get_cell_type(): String {
        return sheetCell.cell_type
    }

    /**
     * 获取单元格值(cell_value)
     */
    override fun get_cell_value(): String {
        return MediaManager().getLatestVedioFiles(File(Util.getMediaFolder(mContext) + File.separator + autoGeneratedSheetID + File.separator +
                cell_name!!.text.toString())).toString()
    }

    /**
     * 获取单元格是否可编辑(cell_editable)
     */
    override fun get_cell_editable(): String {
        return if (sheetCell.cell_editable == SheetProtocol().True) SheetProtocol().True else SheetProtocol().False
    }

    /**
     * 获取单元格是否为必填(cell_fill_required)
     */
    override fun get_cell_fill_required(): String {
        return if (sheetCell.cell_fill_required == SheetProtocol().True) SheetProtocol().True else SheetProtocol().False
    }

    /**
     * 获取单元格是否可打印(cell_printable)
     */
    override fun get_cell_printable(): String {
        return if (sheetCell.cell_printable == SheetProtocol().True) SheetProtocol().True else SheetProtocol().False
    }

    /**
     * 获取单元格是否默认勾选打印(cell_default_print)
     */
    override fun get_cell_default_print(): String {
        return if (sheetCell.cell_default_print == SheetProtocol().True) SheetProtocol().True else SheetProtocol().False
    }

    /**
     * 获取单元格可否被加样(cell_copyable)
     */
    override fun get_cell_copyable(): String {
        return if (sheetCell.cell_copyable == SheetProtocol().True) SheetProtocol().True else SheetProtocol().False
    }

    /**
     * 根据单元格内容生成Json
     */
    override fun getJsonContent(): JSONObject {
        // 转换视频名字为Json
        val vedioFiles = MediaManager().getLatestVedioFiles(File(Util.getMediaFolder(mContext) + File.separator + autoGeneratedSheetID + File.separator +
                cell_name!!.text.toString()))
        var values = ""
        for (index in vedioFiles.indices) {
            if (values.isEmpty())
                values = vedioFiles[index].name
            else
                values = values + "," + vedioFiles[index].name
        }
        // 将内容生成Json
        val json = JSONObject()
        json.put(SheetProtocol().CELL_NAME, get_cell_name())
        json.put(SheetProtocol().CELL_TYPE, get_cell_type())
        json.put(SheetProtocol().CELL_VALUE, values)
        json.put(SheetProtocol().CELL_EDITABLE, get_cell_editable())
        json.put(SheetProtocol().CELL_FILL_REQUIRED, get_cell_fill_required())
        json.put(SheetProtocol().CELL_PRINTABLE, get_cell_printable())
        json.put(SheetProtocol().CELL_DEFAULT_PRINT, get_cell_default_print())
        json.put(SheetProtocol().CELL_COPYABLE, get_cell_copyable())
        return json
    }

    /**
     * 必填的内容是否已经填写
     */
    override fun isFilled(): Boolean {
        if (sheetCell.cell_fill_required == (SheetProtocol().False))
            return true
        else {
            val photosNumber = MediaManager().getLatestVedioFiles(File(Util.getMediaFolder(mContext) + File.separator + autoGeneratedSheetID + File.separator +
                    cell_name!!.text.toString())).size
            return photosNumber != 0
        }

    }

    /**
     * 获取LinearLayout的界面
     */
    override fun getView(): LinearLayout {
        return linearLayout!!
    }

    /**
     * 注册位置信息广播接收器
     */
    fun registerLocationBroadcast() {
        val filter = IntentFilter(Constant.LOCATION_BROADCAST_ACT)
        mContext.registerReceiver(locationReceiver, filter)
    }

    /**
     * 取消注册位置信息广播接收器
     */
    fun unregisterLocationBroadcast() {
        mContext.unregisterReceiver(locationReceiver)
    }

    /**
     * 注册新照片广播接收器
     */
    fun registerNewVedioBroadcast() {
        val filter = IntentFilter(Constant.NEW_VEDIO_BROADCAST_ACT)
        mContext.registerReceiver(newVedioReceive, filter)
    }

    /**
     * 取消注册新照片广播接收器
     */
    fun unregisterNewVedioBroadcast() {
        mContext.unregisterReceiver(newVedioReceive)
    }

    /**
     * 删除新产生的视频文件
     */
    fun deleteNewMediaFiles() {
        for (file in newMediaFiles) {
            file.delete()
        }
    }

    var contentView: View? = null  // 设计的界面
    var linearLayout: LinearLayout? = null
    var cell_name: TextView? = null
    var cell_value: RecyclerView? = null  // 盛放照片
    var gallaryAdaper: GallaryAdaper? = null // 视频首帧照片适配器
    var newMediaFiles = ArrayList<File>()
    var olderMediaFiles = ArrayList<File>()
    var numberIndicator: TextView? = null  // 数量指示器
    var takeVedioButton: Button? = null // 录像按钮
    var cellIdentity = 0  // 拍照单元格的身份ID
    var cell_fill_required: TextView? = null
    var cell_printable: CheckBox? = null
    // Location Info
    var locationPause = false  // 是否暂停定位
    var country = ""  // 国家
    var province = ""  // 省
    var city = ""  // 市
    var district = ""  // 区域
    var street = ""  // 街道
    var longitude = ""  // 经度信息
    var latitude = ""  // 纬度信息
    var location_info_type = BDLocation.TypeOffLineLocation  // 定位类型
    var locationString = ""  // 全面的位置信息

    /**
     * 接受位置信息
     */
    private val locationReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context, intent: Intent) {
            val action = intent.action
            if (Constant.LOCATION_BROADCAST_ACT == action) {
                if (locationPause)
                    return
                val location = intent.getParcelableExtra<BDLocation>(Constant.LOCATION_BROADCAST_VALUE)
                country = location?.country ?: ""
                province = location?.province ?: ""
                city = location?.city ?: ""
                district = location?.district ?: ""
                street = location?.street ?: ""

                longitude = location?.longitude?.toString() ?: ""  // 经度信息
                latitude = location?.latitude?.toString() ?: ""  // 纬度信息
                location_info_type = location?.locType ?: BDLocation.TypeNone  // 定位类型
                var location_type_str = ""  // 定位类型字符
                when (location_info_type) {
                    BDLocation.TypeGpsLocation -> location_type_str = "GPS定位"
                    BDLocation.TypeCacheLocation -> location_type_str = "缓存的位置(此状态无法保存)"
                    BDLocation.TypeNetWorkLocation -> location_type_str = "网络定位"
                    BDLocation.TypeNone -> location_type_str = "无(此状态无法保存)"
                    BDLocation.TypeOffLineLocation -> location_type_str = "离线定位(此状态无法保存)"
                }

                locationString = "定位地址：$province$city$district$street\n经度:$longitude\n纬度:$latitude\n定位类型:$location_type_str"
            }
        }
    }

    /**
     * 接受新照片广播
     */
    private val newVedioReceive = object : BroadcastReceiver() {
        override fun onReceive(context: Context, intent: Intent) {
            val action = intent.action
            if (Constant.NEW_VEDIO_BROADCAST_ACT == action) {
                gallaryAdaper!!.updateUI()
                // 判断新照片
                loop@ for (file in gallaryAdaper!!.vedioFiles) {
                    // 文件是否在老图片列表中，如果在，continue，如果不在加入新列表
                    for (olderFile in olderMediaFiles) {
                        if (file.path == olderFile.path)
                            continue@loop
                    }
                    newMediaFiles.add(file)
                }
            }
        }
    }

    init {
        // 导入界面
        val mInflater: LayoutInflater = LayoutInflater.from(mContext)
        contentView = mInflater.inflate(R.layout.sheet_cell_photos, null)
        // LinearLayout
        linearLayout = contentView!!.findViewById(R.id.cell_edit_text_linear_layout) as LinearLayout
        // 填写单元格的名字
        cell_name = contentView!!.findViewById(R.id.cell_name) as TextView
        cell_name!!.text = sheetCell.cell_name
        // 填写单元格的内容
        cell_value = contentView!!.findViewById(R.id.cell_value) as RecyclerView
        numberIndicator = contentView!!.findViewById(R.id.number_indicator) as TextView
        numberIndicator?.text = ""
        numberIndicator?.visibility = View.GONE
        gallaryAdaper = GallaryAdaper(mContext, MediaManager().getLatestVedioFiles(File(Util.getMediaFolder(mContext) + File.separator + autoGeneratedSheetID + File.separator +
                cell_name!!.text.toString())), autoGeneratedSheetID, cell_name!!.text.toString(), numberIndicator!!)
        cell_value!!.adapter = gallaryAdaper
        val layoutManager = LinearLayoutManager(mContext, LinearLayoutManager.HORIZONTAL, false)
        layoutManager.scrollToPosition(0)// Optionally customize the position you want to default scroll to
        cell_value!!.layoutManager = layoutManager// Attach layout manager to the RecyclerView
        val gridLayoutManager = StaggeredGridLayoutManager(1, StaggeredGridLayoutManager.HORIZONTAL)// First param is number of columns and second param is orientation i.e Vertical or Horizontal
        cell_value!!.layoutManager = gridLayoutManager// Attach the layout manager to the recycler view
        cell_value!!.setHasFixedSize(true)
        // 定义录像按钮功能
        takeVedioButton = contentView!!.findViewById(R.id.takeAPhoto) as Button
        takeVedioButton!!.text = "拍摄视频"
        takeVedioButton!!.onClick {
            // 定位信息准确时才可以录像
            if (location_info_type == BDLocation.TypeGpsLocation ||
                    location_info_type == BDLocation.TypeNetWorkLocation) {
                val video_name = File(Util.getMediaFolder(mContext) + File.separator + autoGeneratedSheetID + File.separator +
                        cell_name!!.text.toString() + File.separator + "VIDEO_" + (mContext.getSystemService(Context.TELEPHONY_SERVICE) as TelephonyManager).deviceId + Util.getCurrentTime("yyMMddHHmmss") + ".mp4")
                var uriVideo: Uri? = null
                if (Build.VERSION.SDK_INT > Build.VERSION_CODES.M)
                    uriVideo = FileProvider.getUriForFile(mContext, mContext.applicationContext.packageName + ".provider", video_name)
                else
                    uriVideo = Uri.fromFile(video_name)
                val intent = Intent(MediaStore.ACTION_VIDEO_CAPTURE)
                intent.putExtra(MediaStore.EXTRA_VIDEO_QUALITY, 0)//更改录像质量 min=0 max =1
                intent.putExtra(MediaStore.EXTRA_OUTPUT, uriVideo)
                if (SheetActivity::class.java.isInstance(mContext))
                    (mContext as SheetActivity).startActivityForResult(intent, SheetActivity.REQUESTCODEFORVIDEO)
            } else
                mContext.toast("正在定位,请稍后...")

        }
        // 生成录像单元格ID
        cellIdentity = ++((mContext as SheetActivity).application as CollectionApplication).cellIdentity
        // 设置单元格可编辑状态(不受该属性影响)
        // ？@##￥￥%%%@#￥！
        // 设置单元格必填状态
        cell_fill_required = contentView!!.findViewById(R.id.cell_fill_required) as TextView
        if (sheetCell.cell_fill_required == (SheetProtocol().False))
            cell_fill_required!!.visibility = View.INVISIBLE
        // 设置单元格默认打印状态
        cell_printable = contentView!!.findViewById(R.id.cell_printable) as CheckBox
        cell_printable!!.setBackgroundResource(R.drawable.selector_checkbox_print)
        cell_printable!!.setButtonDrawable(ColorDrawable(Color.TRANSPARENT))
        cell_printable!!.visibility = View.INVISIBLE
        cell_printable!!.isChecked = sheetCell.cell_default_print == (SheetProtocol().True)
        // 注册新视频录制完成的监听
        registerLocationBroadcast()
        registerNewVedioBroadcast()
    }

    /**
     * 分割字符串
     */
    fun String.splitKeeping(str: String): List<String> {
        return this.split(str).flatMap { listOf(it) }.dropLast(0).filterNot { it.isEmpty() }
    }

    /**
     * RecycleView 的 adapter
     */
    class GallaryAdaper(var mContext: Context, val vedioFiles: ArrayList<File>,
                        val autoGeneratedSheetID: String, val cell_name: String, val numberIndicator: TextView?) : RecyclerView.Adapter<GallaryAdaper.ViewHolder>() {

        val context: Context
            get() = mContext.applicationContext

        override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
            val context = parent.context
            val inflater = LayoutInflater.from(context)

            // Inflate the custom layout
            val contactView = inflater.inflate(R.layout.type_photos_adapter_layout, parent, false)

            // Return a new holder instance
            return ViewHolder(contactView)
        }

        override fun onBindViewHolder(holder: ViewHolder, position: Int) {
            // Get the data model based on position
            val photoFile = vedioFiles[position]

            // Set item views based on your views and data model
            val image = holder.image
            image.viewTreeObserver
                    .addOnGlobalLayoutListener(object : ViewTreeObserver.OnGlobalLayoutListener {
                        // Wait until layout to call Picasso
                        override fun onGlobalLayout() {
                            // Ensure we call this only once
                            image.viewTreeObserver
                                    .removeOnGlobalLayoutListener(this)
                        }
                    })

            if (photoFile.exists()) {
                if (ContextCompat.checkSelfPermission(mContext, Manifest.permission.READ_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED) {
                    val thumb = createVideoThumbnail(photoFile.path, 0)
                    if (thumb == null)
                        image.setImageResource(R.drawable.image_read_fail)
                    else
                        Picasso.with(mContext).load(getBitmapUri(mContext, thumb)).resize(0,
                                ScreenUtil.dpToPx(mContext, DEFAULT_IMAGE_HEIGHT_DP)).into(image)
                } else {
                    image.setImageResource(R.drawable.image_read_fail)
                }
            } else {
                image.setImageResource(R.drawable.image_read_fail)
                doAsync {
                    downloadFile(URLs.DOWNLOAD_IMG_PATH + photoFile.name, photoFile)
                    uiThread {
                        if (ContextCompat.checkSelfPermission(mContext, Manifest.permission.READ_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED) {
                            val thumb = createVideoThumbnail(photoFile.path, 0)
                            if (thumb == null)
                                image.setImageResource(R.drawable.image_read_fail)
                            else
                                Picasso.with(mContext).load(getBitmapUri(mContext, thumb)).resize(0,
                                        ScreenUtil.dpToPx(mContext, DEFAULT_IMAGE_HEIGHT_DP)).into(image)
                        } else {
                            image.setImageResource(R.drawable.image_read_fail)
                        }
                    }
                }
            }

            image.setOnClickListener {
                //其他的是查看录像
                val vedioURI = FileProvider.getUriForFile(mContext, "com.aj.collection.fileprovider", photoFile)
                val type = "video/mp4"
                val intent = Intent(Intent.ACTION_VIEW)
                intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION)
                intent.setDataAndType(vedioURI, type)
                mContext.startActivity(intent)
            }
            val button = holder.removeButton

            button.setOnClickListener {
                photoFile.delete()
                updateUI()
            }
        }

        override fun getItemCount(): Int {
            return vedioFiles.size
        }

        fun updateUI() {
            this.vedioFiles.clear()
            this.vedioFiles.addAll(MediaManager().getLatestVedioFiles(
                    File(Util.getMediaFolder(mContext) + File.separator + autoGeneratedSheetID + File.separator + cell_name)
            ))
            this.notifyDataSetChanged()
            // 更新指示器
            if (this.vedioFiles.isEmpty()) {
                numberIndicator?.text = ""
                numberIndicator?.visibility = View.GONE
            } else {
                numberIndicator?.visibility = View.VISIBLE
                numberIndicator?.text = "已录像" + this.vedioFiles.size.toString() + "个，左右滑动浏览，点击播放视频"
            }
        }

        fun updateUI(vedioFiles: ArrayList<File>) {
            this.vedioFiles.clear()
            this.vedioFiles.addAll(vedioFiles)
            this.notifyDataSetChanged()
            // 更新指示器
            if (this.vedioFiles.isEmpty()) {
                numberIndicator?.text = ""
                numberIndicator?.visibility = View.GONE
            } else {
                numberIndicator?.visibility = View.VISIBLE
                numberIndicator?.text = "已录像" + this.vedioFiles.size.toString() + "个，左右滑动浏览，点击播放视频 "
            }
        }

        // Provide a direct reference to each of the views within a data item
        // Used to cache the views within the item layout for fast access
        class ViewHolder// We also create a constructor that accepts the entire item row
        // and does the view lookups to find each subview
        (itemView: View) : RecyclerView.ViewHolder(itemView) {
            // Your holder should contain a member variable
            // for any view that will be set as you render a row
            var image: ImageView
            var removeButton: CircleButton

            init {

                image = itemView.findViewById(R.id.gallary_image) as ImageView
                removeButton = itemView.findViewById(R.id.remove_gallary_button) as CircleButton
            }// Stores the itemView in a public final member variable that can be used
            // to access the context from any ViewHolder instance.
        }



        fun downloadFile(fileURL: String, file: File) {
            try {
                file.parentFile.mkdir()
                var url = URL(fileURL)
                var c = url.openConnection() as HttpURLConnection
                c.requestMethod = "GET"
                c.doOutput = true
                c.connect()
                var f = FileOutputStream(file);
                var inputStream = c.inputStream
                var buffer = ByteArray(1024)
                var len1 = 0
                while (true) {
                    len1 = inputStream.read(buffer)
                    if (len1 > 0)
                        f.write(buffer, 0, len1)
                    else
                        break
                }
                f.close()
            } catch (e: IOException) {
                e.printStackTrace()
            }

        }
    }
}